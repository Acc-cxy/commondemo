<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>

		<script>
			function Dog(name){
				return this.name = name
			}
			Dog.prototype.sayName = function(){
				// console.log(this.name)
			}// 上面是本身Dog
			function _new(fn,...args){   // ...args为ES6展开符,也可以使用arguments
										 //先用Object创建一个空的对象,
				const obj = Object.create(fn.prototype)  //fn.prototype代表 用当前对象的原型去创建
				//现在obj就代表Dog了,但是参数和this指向没有修改
				const rel = fn.call(obj,...args)
				//正常规定,如何fn返回的是null或undefined(也就是不返回内容),我们返回的是obj,否则返回rel
				return rel instanceof Object ? rel : obj
			}
			var _newDog = _new(Dog,'这是用_new出来的小狗',"是真的")
			console.log(_newDog)
			_newDog.sayName()
			//
			// function 士兵(ID){
			// 	this.ID = ID
			//   	this.生命值 = 100
			// }
			// 士兵.prototype = {
			//   兵种:"美国大兵",
			//   攻击力:5,
			//   行走:function(){ /*走俩步的代码*/},
			//   奔跑:function(){ /*狂奔的代码*/  },
			//   死亡:function(){ /*Go die*/    },
			//   攻击:function(){ /*糊他熊脸*/   },
			//   防御:function(){ /*护脸*/       }
			// }
			class 士兵{
				constructor(id) {
					this.id = id;
					this.生命值 = 100;
					if(id !==1){
						this.id = 10;
						console.log(1)
					}
				}
				行走(){ /*走俩步的代码*/console.log("return")};
				奔跑(){ /*狂奔的代码*/  };
				死亡(){ /*Go die*/    };
				攻击(){ /*糊他熊脸*/    };
				防御(){ /*护脸*/       };
			}
			class 将军 extends 士兵{
				constructor(id) {
					super(id);
					this.将军加成 = id*2;
				}
				static halo(){
					return "1122"
				}
			}
			const a = new 将军(5)
			console.log(a)









			var 士兵们 = []
			for(var i=0; i<100; i++){
			  	// 士兵们.push(new 士兵(i))
			}
		</script>
	</body>
</html>
